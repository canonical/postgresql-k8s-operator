# Copyright 2025 Canonical Ltd.
# See LICENSE file for licensing details.

"""Authorisation rules changes observer."""

import json
import subprocess
import sys
from ssl import CERT_NONE, create_default_context
from time import sleep
from urllib.parse import urljoin
from urllib.request import urlopen

API_REQUEST_TIMEOUT = 5
PATRONI_CLUSTER_STATUS_ENDPOINT = "cluster"
PATRONI_CONFIG_STATUS_ENDPOINT = "config"


class UnreachableUnitsError(Exception):
    """Cannot reach any known cluster member."""


def dispatch(run_cmd, unit, charm_dir):
    """Use the input juju-run command to dispatch a :class:`AuthorisationRulesChangeEvent`."""
    dispatch_sub_cmd = "JUJU_DISPATCH_PATH=hooks/authorisation_rules_change {}/dispatch"
    # Input is generated by the charm
    subprocess.run([run_cmd, "-u", unit, dispatch_sub_cmd.format(charm_dir)])  # noqa: S603


def main():
    """Main watch and dispatch loop.

    Watch the Patroni API cluster info. When changes are detected, dispatch the change event.
    """
    patroni_urls, run_cmd, unit, charm_dir = sys.argv[1:]

    previous_authorisation_rules = []
    urls = [urljoin(url, PATRONI_CLUSTER_STATUS_ENDPOINT) for url in patroni_urls.split(",")]
    member_name = unit.replace("/", "-")
    while True:
        # Disable TLS chain verification
        context = create_default_context()
        context.check_hostname = False
        context.verify_mode = CERT_NONE

        cluster_status = None
        for url in urls:
            try:
                # Scheme is generated by the charm
                resp = urlopen(  # noqa: S310
                    url,
                    timeout=API_REQUEST_TIMEOUT,
                    context=context,
                )
                cluster_status = json.loads(resp.read())
                break
            except Exception as e:
                print(f"Failed to contact {url} with {e}")
                continue
        if not cluster_status:
            raise UnreachableUnitsError("Unable to reach cluster members")
        is_primary = False
        for member in cluster_status["members"]:
            # Check if the current member is the primary.
            if member["name"] == member_name and member["role"] == "leader":
                is_primary = True
                break

        if is_primary:
            # Read contents from the pg_hba.conf file.
            with open("/var/lib/postgresql/data/pgdata/pg_hba.conf") as file:
                current_authorisation_rules = file.read()
                current_authorisation_rules = [
                    line
                    for line in current_authorisation_rules.splitlines()
                    if not line.startswith("#")
                ]
            # If it's the first time the authorisation rules were retrieved, then store it and use
            # it for subsequent checks.
            if not previous_authorisation_rules:
                previous_authorisation_rules = current_authorisation_rules
            # If the authorisation rules changed, dispatch a charm event to handle this change.
            elif current_authorisation_rules != previous_authorisation_rules:
                previous_authorisation_rules = current_authorisation_rules
                dispatch(run_cmd, unit, charm_dir)

        # Wait some time before checking again for a authorisation rules change.
        sleep(30)


if __name__ == "__main__":
    main()
