# Copyright 2025 Canonical Ltd.
# See LICENSE file for licensing details.

"""Authorisation rules observer."""

import logging
import os
import signal
import subprocess
import typing

from ops.charm import CharmEvents
from ops.framework import EventBase, EventSource, Object
from ops.model import ActiveStatus

if typing.TYPE_CHECKING:
    from charm import PostgresqlOperatorCharm

logger = logging.getLogger(__name__)

# File path for the spawned authorisation rules observer process to write logs.
LOG_FILE_PATH = "/var/log/authorisation_rules_observer.log"


class AuthorisationRulesChangeEvent(EventBase):
    """A custom event for authorisation rules changes."""


class AuthorisationRulesChangeCharmEvents(CharmEvents):
    """A CharmEvents extension for authorisation rules changes.

    Includes :class:`AuthorisationRulesChangeEvent` in those that can be handled.
    """

    authorisation_rules_change = EventSource(AuthorisationRulesChangeEvent)


class AuthorisationRulesObserver(Object):
    """Observes authorisation rules changes.

    Args:
        charm: the charm that is instantiating the library.
        run_cmd: run command to use to dispatch events.
    """

    def __init__(self, charm: "PostgresqlOperatorCharm", run_cmd: str):
        super().__init__(charm, "authorisation-rules-observer")

        self._charm = charm
        self._run_cmd = run_cmd

    def start_authorisation_rules_observer(self):
        """Start the authorisation rules observer running in a new process."""
        container = self._charm.unit.get_container("postgresql")
        if (
            not isinstance(self._charm.unit.status, ActiveStatus)
            or self._charm._peers is None
            or not container.can_connect()
            or not self._charm.is_cluster_initialised
        ):
            return

        if "authorisation-rules-observer-pid" in self._charm.unit_peer_data:
            pid = int(self._charm.unit_peer_data["authorisation-rules-observer-pid"])
            try:
                os.kill(pid, 0)  # Check if the process exists
                return
            except OSError:
                pass

        logger.info("Starting the authorisation rules observer")

        # We need to trick Juju into thinking that we are not running
        # in a hook context, as Juju will disallow use of juju-run.
        new_env = os.environ.copy()
        new_env.pop("JUJU_CONTEXT_ID", None)

        urls = [
            self._charm._patroni._patroni_url.replace(self._charm.endpoint, endpoint)
            for endpoint in self._charm._endpoints
        ]

        # Input is generated by the charm
        process = subprocess.Popen(  # noqa: S603
            [
                "/usr/bin/python3",
                "scripts/authorisation_rules_observer.py",
                ",".join(urls),
                self._run_cmd,
                self._charm.unit.name,
                self._charm.charm_dir,
            ],
            # File shouldn't close
            stdout=open(LOG_FILE_PATH, "a"),  # noqa: SIM115
            stderr=subprocess.STDOUT,
            env=new_env,
        )

        self._charm.unit_peer_data.update({"authorisation-rules-observer-pid": str(process.pid)})
        logger.info(f"Started authorisation rules observer process with PID {process.pid}")

    def stop_authorisation_rules_observer(self):
        """Stop the authorisation rules observer process."""
        if (
            self._charm.peers is None
            or "authorisation-rules-observer-pid" not in self._charm.unit_peer_data
        ):
            return

        authorisation_rules_observer_pid = int(
            self._charm.unit_peer_data["authorisation-rules-observer-pid"]
        )

        try:
            os.kill(authorisation_rules_observer_pid, signal.SIGTERM)
            logger.info(
                f"Stopped authorisation rules observer process with PID {authorisation_rules_observer_pid}"
            )
            del self._charm.unit_peer_data["authorisation-rules-observer-pid"]
        except OSError:
            pass
