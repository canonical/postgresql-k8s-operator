# Copyright 2025 Canonical Ltd.
# See LICENSE file for licensing details.

"""Authorisation rules observer."""

import logging
import os
import signal
import subprocess
import typing
from pathlib import Path
from sys import version_info

from ops.charm import CharmEvents
from ops.framework import EventBase, EventSource, Object
from ops.model import ActiveStatus

if typing.TYPE_CHECKING:
    from charm import PostgresqlOperatorCharm

logger = logging.getLogger(__name__)

# File path for the spawned authorisation rules observer process to write logs.
LOG_FILE_PATH = "/var/log/authorisation_rules_observer.log"


class DatabasesChangeEvent(EventBase):
    """A custom event for databases changes."""


class AuthorisationRulesChangeCharmEvents(CharmEvents):
    """A CharmEvents extension for authorisation rules changes.

    Includes :class:`DatabasesChangeEventt` in those that can be handled.
    """

    databases_change = EventSource(DatabasesChangeEvent)


class AuthorisationRulesObserver(Object):
    """Observes authorisation rules changes.

    Args:
        charm: the charm that is instantiating the library.
        run_cmd: run command to use to dispatch events.
    """

    def __init__(self, charm: "PostgresqlOperatorCharm", run_cmd: str):
        super().__init__(charm, "authorisation-rules-observer")

        self._charm = charm
        self._run_cmd = run_cmd

    def start_authorisation_rules_observer(self):
        """Start the authorisation rules observer running in a new process."""
        container = self._charm.unit.get_container("postgresql")
        if (
            not isinstance(self._charm.unit.status, ActiveStatus)
            or self._charm._peers is None
            or not container.can_connect()
            or not self._charm.is_cluster_initialised
        ):
            return

        if "authorisation-rules-observer-pid" in self._charm.unit_peer_data:
            pid = int(self._charm.unit_peer_data["authorisation-rules-observer-pid"])
            try:
                os.kill(pid, 0)  # Check if the process exists
                return
            except OSError:
                pass

        logger.info("Starting the authorisation rules observer")

        # We need to trick Juju into thinking that we are not running
        # in a hook context, as Juju will disallow use of juju-run.
        new_env = os.environ.copy()
        new_env.pop("JUJU_CONTEXT_ID", None)
        # Generate the venv path based on the existing lib path
        for loc in new_env["PYTHONPATH"].split(":"):
            path = Path(loc)
            venv_path = (
                path
                / ".."
                / "venv"
                / "lib"
                / f"python{version_info.major}.{version_info.minor}"
                / "site-packages"
            )
            if path.stem == "lib":
                new_env["PYTHONPATH"] = f"{venv_path.resolve()}:{new_env['PYTHONPATH']}"
                break

        urls = [
            self._charm._patroni._patroni_url.replace(self._charm.endpoint, endpoint)
            for endpoint in self._charm._endpoints
        ]

        # Input is generated by the charm
        process = subprocess.Popen(  # noqa: S603
            [
                "/usr/bin/python3",
                "scripts/authorisation_rules_observer.py",
                ",".join(urls),
                self._run_cmd,
                self._charm.unit.name,
                self._charm.charm_dir,
            ],
            # File shouldn't close
            stdout=open(LOG_FILE_PATH, "a"),  # noqa: SIM115
            stderr=subprocess.STDOUT,
            env=new_env,
        )

        self._charm.unit_peer_data.update({"authorisation-rules-observer-pid": str(process.pid)})
        logger.info(f"Started authorisation rules observer process with PID {process.pid}")

    def stop_authorisation_rules_observer(self):
        """Stop the authorisation rules observer process."""
        if (
            self._charm._peers is None
            or "authorisation-rules-observer-pid" not in self._charm.unit_peer_data
        ):
            return

        authorisation_rules_observer_pid = int(
            self._charm.unit_peer_data["authorisation-rules-observer-pid"]
        )

        try:
            os.kill(authorisation_rules_observer_pid, signal.SIGTERM)
            logger.info(
                f"Stopped authorisation rules observer process with PID {authorisation_rules_observer_pid}"
            )
            del self._charm.unit_peer_data["authorisation-rules-observer-pid"]
        except OSError:
            pass
